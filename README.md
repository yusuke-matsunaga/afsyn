# アフィン変換回路生成器

<div style="text-align:right;">
松永 裕介<br>
2020.10.15 Ver.1<bt>
</div>


## はじめに

deep learning では入力信号を複数の演算層で処理した結果を出力するが，
その各層で行われる主要な処理の一つにアフィン変換(Affine
transformation)がある．
定義上，アフィン変換層ではすべての入力信号がすべての出力信号に関係していることなる（そのため「全結合層」の別名を持つ）が，
実際にはアフィン変換行列が非常に疎な場合が多い．
その場合，単純に行列演算の定義に従って全要素の演算を網羅的に行うのは効率が悪い．
そこで，与えられたデータに合わせて専用のアフィン変換を行うハードウェアを合成するプログラムを開発する．


## アフィン変換

アフィン変換は以下の式で表される

Y = A・X

ここで A はアフィン変換行列，Xは入力信号(ベクトル)，Yは出力信号(ベクトル)である．
上の式を展開すると以下のようになる．

Y<sub>i</sub> = Σ<sub>j</sub> A<sub>ij</sub>・X<sub>j</sub>

ここで A_{ij} はAのi行i列の要素を表す．
行列のサイズをm行n列とすると上の式では m × n 回の乗算と加算を行う必要がある．
ただし，A<sub>ij</sub>が0の場合，この項に関する演算は無意味であり省略できる．
さらに今回はA<sub>ij</sub>の値の種類も 0.125, 0.25, -0.125
の３種類のみと限定された場合を考える．
0.125 は 1/8 であり2進数を3ビット右シフトすることで実現できる．
0.25 は 0.125 の2倍であり，同じ値を2回加算することで実現できる．
-0.125 は 0.125 にマイナスを掛けたものなので，
最終結果を3ビット右シフトすることで1/8倍するとすると，
この例のアフィン変換では係数の乗算は必要なく，
加算と2回の加算と減算だけで実現できる．


## Data Flow Graph

ここでは実現する演算を表すために Data Flow Graph(DFG) を用いる．
DFGは計算構造を表す非巡回有向グラフ(DAG)である．
DFGのノードは以下の3種類からなる．
* 入力ノード(入力メモリノード)
  入力値(を納めたメモリのアドレス)を表す．
  入力メモリからの読み出し動作を行う．
* 演算ノード
  計算を表す．
* 出力ノード(出力メモリノード)
  計算結果(を格納するメモリのアドレス)を表す．
  結果を出力メモリに書き出す動作を行う．


## スケジューリングとバインディング

単純にはDFGの演算ノードを一つずつ実際の演算器ハードウェアに割り当てるとDFGの計算を行うハードウェアを実現することができる．
しかし，ノード数が多い場合，ノード数と等しい個数の演算器を用意することは現実的ではない．
そこで，計算の実行を複数クロックに分割して一つの演算器を複数のノードで時分割で共有することで使用する演算器の個数を減らす方法が考えられる．
一般に実行クロック数を増やせばより多くの演算ノードが共有可能となるが，
具体的には個々の演算ノードがどのタイミングで実行されるかがわからないと共有可能かどうかはわからない．
そこで，DFGの各ノードの実行タイミングを決定する処理を「スケジューリング」とよぶ．

スケジューリングが決まるとDFGの実行にかかるクロック数(ステップ数)と必要になる演算器の個数(の最小値)が決定される．
しかし，演算器の共有を行うためには入力や出力の切り替えを行うハードウェア(セレクタ，もしくはマルチプレクサ)が必要となる．
また，演算に用いる値が1クロック以上前のクロックで生成されていた場合，
その値を保存しておくためのレジスタが必要となる．
これらの付加的なハードウェアは，
実際にどのノードを共有するかを決めなければ決まらない．
この処理を「バインディング」と呼ぶ．

スケジューリングもバインディングも単純に決められるものではなく様々な方法が考えられる．
さらにスケジューリング・バインディング結果に応じて計算ステップ数と必要となるハードウェア量が変わってくるため，
適切な方法を選ぶ必要がある．


## 具体例

`data/Affine_W.op`

の例について説明する．

このファイルは1行で1つの出力に関する計算式を表している．
ただし，`#`で始まる行はコメントであり無視される．
例えば最初の行は以下のようになっている．

```
0: (15, 0.125), (70, -0.125), (87, -0.125), ・・・
```

最初の`0:` はこの行が0番目の出力のものであることを示している．
その後につづく`(15, 0.125)`は15番目の入力に係数 0.125 を掛けることを表している．
以下同様である．
係数0の項は省略されている．
先頭のコメントに書いてあるようにこの例では入力のサイズは 1536，
出力のサイズは 1000 である．
そのため仮想的には 1,536,000 の演算が必要であるが，
実際には


## 基本演算

上記の例で用いられている係数は 0.125, -0.125, 0.25 の3種類のみである．
そこで，最終結果を1/8する(3ビット右シフト)することにすれば，
各係数はそれぞれ1, -1, 2となる．
-1を掛けるということは「2の補数」を求めることに他ならない．
2の補数はもとの2進数の0と1を反転させた結果に1を足せばよい．
2倍するのは左に1ビットシフトすればよいが，
値がオーバーフローする可能性があるので，
同じ入力を2回足すことにする．
すると係数を乗算する回路はほぼ不要となり加算回路のみあればよいことになる(2の補数の1を足す部分も含む)．
さらに，加算は1度に2つの数を足し合わせるよりも複数の数を足し合わせるほうが効率がよい．
そこで今回は16入力の加算器を基本演算器として用いることとする．
今回の例では1つの出力に対する最大の入力数は200程度なので，
16入力の加算器を2段組み合わせることで対応する．
すると16 × 16 = 256 入力まで対応可能である．
この例ではこの16入力加算器を基本演算とする．


## 演算器のビット幅

今回の例では入力データは8ビット幅で与えられる．
基本的に8ビットどうしの加算の結果を誤差なく表すためには9ビット必要となる．
同様に8ビットの入力を16個同時に足し合わせる場合結果は12ビット必要となる．

すると2段めの16入力加算器は入力が12ビット，出力が16ビットとなる．
そのため，16入力加算器は1段めと2段めで異なるビット幅のものを用意する必要がある．


## メモリ配置

アフィン変換では大量にメモリアクセスが発生する．
そのため，単一のメモリブロックを用いているとメモリアクセスがボトルネックとなって所持時間の短縮が行えない．
そこで，入力データを保持するメモリブロックを複数に分割して同時にアクセスできるデータ数を増やすことを考える．
さらに，一度にアクセスできるデータのビット幅を拡げることによってアクセススピードの向上を図る．

* 入力データをいくつのブロックに分割するのか，
* 各々のメモリブロックにどのように入力データを分散させるのか．
* さらに，同一ブロック内にデータをどのように配置させるのか，

によって結果が変わってくるため，工夫する必要がある．


## 前処理

前述のように入力データはグループ化されておらずバラバラに与えられる．
そのため16入力加算器を基本演算としたDFGを作るためには，
入力データを最大16入力の加算ノードに分割する必要がある．
どの入力を同じグループにするかによって最終的な結果が変わってくるが，
現在はどのようなグループ化がよいのかを表すよい指標が思いつかないので適当に分割することとする．
余裕があればこのグループ化の方法も検討課題である．


## スケジューリング

DFG が出来上がったらスケジューリングを行う．
スケジューリングではDFGの各ノードが実行されるタイミングを決定する．
ここではこのタイミングのことを 'コントロールステップ' と呼ぶ．
ただし，ハードウェアによって動作の完了までに複数クロックを要するものもあるため，
動作を開始するタイミングと終了するタイミングには注意が必要である．

スケジューリング対象のノードは以下の通りである．

* 演算ノード
  ここでは16入力の加算ノード(2種類)のみである．
  スケジューリングに関する制約としては，

  * すべての入力ノードの終了タイミングが自分の開始タイミングより早いこと．
  * 同じコントロールステップ中で動作する同種の演算ノードの数が制約以下であること．

  の2つがある．

* 入力メモリノード
  入力メモリからのデータの読み出しを行う．
  スケジューリングに関する制約としては，

  * 同じコントロールステップ中で同じメモリブロックに関して異なるデータの読み出しが行われていないこと．

  のみである．ただし，同じデータを2箇所で読み出すことは問題ない．

* 出力メモリノード
  演算結果を書き込む．
  スケジューリングに関する制約としては，

  * 入力となっている演算ノードの終了タイミングよりも遅いこと．
  * 同じコントロールステップ中で同じメモリブロックに関して異なるデータの書き込みが行われていないこと．

  の2つである．


## バインディング

バインディング処理ではスケジューリングされたDFGの各ノードを実際の演算器に割り当てる．
メモリノードに関しては結果は一意に定まる．
演算ノードも同じコントロールステップで実行される演算ノードどうしが同じ演算器に割り当てられない限り，
どのような割り当てを行っても実行可能なハードウェアを生成することは可能である．
実際には，DFGから対応するハードウェアを生成する際にDFGには直接現れない付加的なハードウェアが生成されている．
このうち，バインディングの影響を受けるものが中間レジスタとセレクタ(マルチプレクサ)である．
中間レジスタはDFGノード間に1クロック以上の空きがある場合にその演算結果を保持しておくために必要となる．
セレクタはひとつの演算器に複数の演算ノードを割り当てた場合にどの演算ノードの演算を実行するかに応じて入力を切り替えるものである．
中間レジスタを共有した場合も同様にセレクタが必要となる．

明らかに演算ノードのバインディングの結果が生成されるレジスタおよびセレクタの数に影響を与えるが，
最適な演算ノードのバインディング法というものは知られていない(というかたぶん効率の良いアルゴリズムは存在しない)．
そこで，同時に使用できない演算ノードどうしを避けて同じ演算器に割り当てるヒューリスティックが用いられる．

## 実装の詳細

### dfg.py

DFG を表すデータ構造を実装している．
DFG のノードはクラス'''Node'''とその継承クラスが実装している．

* Node
  DFGのノードの基底クラス．
  以下のメンバ関数を持つ．

  * __init__(self, id, fanin_list, latency)
    初期化を行う．
	id は各ノードに固有のID番号．
	fanin_list はファンインのノードのリスト．
	latency はそのノードの開始タイミングと終了タイミングの差を表す．
	通常は1クロックで動作が終わるので1だが，
	メモリアクセスは2クロック必要となる．

  * bind(self, unit)
	ノードに演算器を割り当てる．

  * id(self)
	ID番号を返す．この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * unit(self)
    バインドしているユニットを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * fanin_num(self)
	ファンイン数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * fanin(self, pos)
    pos 番目のファンインを返す．

  * fanin_list(self)
	ファンインのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * is_memsrc(self)
	メモリソースノード(後述)の時 True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * is_memsink(self)
	メモリシンクノード(後述)の時 True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * is_op1(self)
    一段目の演算子ノード(後述)の時 True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * is_op2(self)
    二段目の演算子ノード(後述)の時 True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * set_schedule(self, cstep)
	このノードのスケジュールをセットする．

  * cstep(self)
    このノードのスケジュールされたコントロールステップを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * next_step(self)
    このノードの結果を使用できる最速のコントロールステップを返す．
	具体的には cstep に latency を足した値を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * latency(self)
	このノードの latency を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * attach_var(self, var)
	このノードに関連する変数をセットする．

  * var(self)
	このノードに関連する変数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

* MemNode
  メモリアクセスを行うノードの基底クラス．
  もちろん Node の継承クラス

  * __init__(self, id, latency, addr, block_id, bank_id, offset)
	初期化を行う．
	内部で Node.__init__()を呼んでいる．
	もちろんファンインはないので fanin_list は空リストとなる．
	このクラスとして付加されているパラメータは以下の通り

	* addr: 対象のメモリアドレス．実際には入力データの番号
	* block_id: メモリブロック番号
	* bank_id: メモリバンク番号
	* offset: バンク内オフセット

	メモリレイアウトが定まれば addr <-> block_id, bank_id, offset
	間の相互変換は可能だがここでは利便性のために両方のデータを持っている．

  * addr(self)
	対象のメモリアドレスを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * block_id(self)
	メモリブロック番号を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * bank_id(self)
	バンク番号を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * offset(self)
	オフセットを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．


* MemSrcNode
  メモリソースノードを表すクラス．
  MemNode の継承クラス

  * __init__(self, id, addr, block_id, bank_id, offset)
    初期化を行う．
	内部で MemNode.__init__() を呼んでいる．
	メモリ読み出しにはアドレスの確定に１クロック必要でその後読み出しに
	1クロック要するのでlatencyは2となる．

  * is_memsrc(self)
	メモリソースノードの時に True を返す．
	このクラスでは常に True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * print(self)
	このノードを名前を出力する．

  * simulate(self, ivals, val_dict, debug)
	シミュレーションを行う．
	ivals は入力データの値を納めた辞書．
	キーはメモリアドレス．
	val_dict は演算ノードの値を納めた辞書
	シミュレーション結果は val_dict に書き込まれる．
	debug フラグが True の時はデバッグ情報を出力する．


* MemSinkNode
  メモリシンクノードを表すクラス．
  MemNode の継承クラス

  * __init__(self, id, addr, block_id, bank_id, offset, src)
	初期化を行う．
	内部で MemNode.__init__() を呼んでいる．
	メモリ書き込みは１クロックで行える．
	src は書き込む値を計算する演算ノード

  * is_memsink(self)
	メモリシンクノードの時に True を返す．
	このクラスでは常に True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * src(self)
	入力ソースを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * print(self)
	このノードを名前を出力する．

  * simulate(self, ivals, val_dict, debug)
	シミュレーションを行う．
	ivals は入力データの値を納めた辞書．
	キーはメモリアドレス．
	val_dict は演算ノードの値を納めた辞書
	シミュレーション結果は val_dict に書き込まれる．
	debug フラグが True の時はデバッグ情報を出力する．


* OpNode
  演算ノードを表すクラス．
  Node の継承クラス

  * __init__(self, id, op_id, fanin_list)
	初期化を行う．
	内部で Node.__init__() を呼んでいる．
	op_id は演算器番号を表す．
	演算器番号は演算ノードに対してユニークに割り当てる．

  * op_id(self)
	演算器番号を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * set_fanout(self, onode)
	ファンアウトノードをセットする．
	今回のDFGではファンアウトノードは高々ひとつである．

  * fanout(self)
	ファンアウトを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．


* Op1Node
  １段めの演算ノードを表すクラス
  OpNode の継承クラス

  * __init__(self, id, op_id, fanin_list, weight_list)
	初期化を行う．
	内部で OpNode.__init__() を呼んでいる．
	weight_list は各ファンインの重みのリスト．
	値は 0.125, -0.125, 0.25 のいづれか．

  * is_op1(self)
	1段目の演算ノードの時rに True を返す．
	このクラスでは常に True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * weight(self, pos)
	pos 番目の入力の重みを返す．

  * weight_list(sefl)
	重みのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * print(self)
	このノードを名前を出力する．

  * simulate(self, ivals, val_dict, debug)
	シミュレーションを行う．
	ivals は入力データの値を納めた辞書．
	キーはメモリアドレス．
	val_dict は演算ノードの値を納めた辞書
	シミュレーション結果は val_dict に書き込まれる．
	debug フラグが True の時はデバッグ情報を出力する．


* Op2Node
  2段めの演算ノードを表すクラス
  OpNode の継承クラス

  * __init__(self, id, op_id, fanin_list)
	初期化を行う．
	内部で OpNode.__init__() を呼んでいる．
	fanin_list の内容をスキャンして負の重みを持つ入力の数を数える．
	2の補数の補正のためにその数を足す必要がある．

  * is_op2(self)
	2段目の演算ノードの時rに True を返す．
	このクラスでは常に True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * bias(self)
	バイアス値(負の係数を持つ入力数)を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * print(self)
	このノードを名前を出力する．

  * simulate(self, ivals, val_dict, debug)
	シミュレーションを行う．
	ivals は入力データの値を納めた辞書．
	キーはメモリアドレス．
	val_dict は演算ノードの値を納めた辞書
	シミュレーション結果は val_dict に書き込まれる．
	debug フラグが True の時はデバッグ情報を出力する．

* Var
  変数を表すクラス．
  変数はノードの出力と対応付けられる．
  バインディング時にはレジスタに割り当てる対象となる．
  スケジュール結果を必要とするため，スケジューリングが終わった
  DFGに対して設定される．

  * __init__(self, src, start)
	初期化を行う．
	src は入力となっているノード．
	メモリソースノードか演算ノード
	start は入力の値が利用可能となるコントロールステップ

  * add_tgt(self, tgt)
	ターゲット(tgt)を追加する．
	ターゲットは演算ノードかメモリシンクノード

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * src(self)
	ソースノードを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * tgt_list(self)
	ターゲットのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * start(self)
	この変数の値が利用可能となる開始時刻を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * end(self)
	この変数の値を参照している最後の時刻を返す．
	つまり，この時刻までこの変数の値が保存されていなければならない．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * check_overlap(self, start, end)
	他の(start, end)の区間を持つ変数と時区間が重複しているか調べる．
	* 重複していた場合，共通な区間を表すタプルを返す．
	* 重複していなかった場合，None を返す．

  * unit(self)
	バインドしているユニットを返す．
	通常はレジスタにバインドしているが，ロードユニットの場合もある．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * bind(self, unit)
	バインドする．

  * print(self)
	このノードを名前を出力する．

  * __lt__(self, other)
	小なり比較演算子．
	a < b の様に用いる．

* DFG
  DFG を表すクラス

  * __init__(self, op1_limit, op2_limit, imem_layout, omem_layout)
	初期化を行う．
	op1_limit は1段めの演算ノードのファンイン数制約．
	op2_limit は2段めの演算ノードのファンイン数制約．
	imem_layout は入力メモリのレイアウト情報．
	omem_layout は出力メモリのレイアウト情報．
	これらは補助的な情報を持つパラメータであり，
	グラフそのものは空の状態で初期化される．

  * op1_limit(self)
	1段めの演算ノードのファンイン数制約を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op2_limit(self)
	2段めの演算ノードのファンイン数制約を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * imem_layout(self)
	入力メモリのレイアウト情報を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * omem_layout(self)
	出力メモリのレイアウト情報を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * make_memsrc(self, i_id)
	メモリソースノードを作る．
	i_id は入力データの番号であり，
	これと入力メモリのレイアウトからブロック番号，バンク番号，オフセットが作られる．

  * make_memsink(self, o_id)
	メモリシンクノードを作る．
	o_id は出力データの番号であり，
	これと出力メモリのレイアウトからブロック番号，バンク番号，オフセットが作られる．

  * make_op1(self, fanin_list, weight_list)
	1段目の演算器ノードを作る．

  * make_op2(self, fanin_list)
	2段目の演算器ノードを作る．

  * node_num(self)
	ノード数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * node_list(self)
	全てのノードのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * memsrcnode_num(self)
	メモリソースノード数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * memsrcnode_list(self)
	メモリソースノードのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * memsinknode_num(self)
	メモリシンクノード数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * memsinknode_list(self)
	メモリシンクノードのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op1node_num(self)
	1段目の演算器ノード数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op1node_list(self)
	1段目の演算器ノードのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op2node_num(self)
	2段目の演算器ノード数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op2node_list(self)
	2段目の演算器ノードのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * total_step(self)
	総ステップ数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op1_num(self)
	必要となる１段めの演算器数を返す．
	この関数を呼ぶ前に eval_resource() を呼んでおく必要がある．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op2_num(self)
	必要となる2段めの演算器数を返す．
	この関数を呼ぶ前に eval_resource() を呼んでおく必要がある．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * reg_list(self)
	必要となるレジスタの数を返す．
	この関数を呼ぶ前に eval_resource() を呼んでおく必要がある．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * var_list(self)
	変数のリストを返す．
	この関数を呼ぶ前に eval_resource() を呼んでおく必要がある．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * eval_resource(self)
	変数の生成を行い，リソース量の見積もりを行う．
	この関数を呼ぶ前に各ノードのスケジュールが確定している必要がある．

  * print(self)
	内容を出力する．

  * simulate(self, ivals, debug)
	シミュレーションを行う．
	ivals は入力データの値を納めた辞書．
	キーはメモリアドレス．
	debug フラグが True の時はデバッグ情報を出力する．
	出力値を格納した辞書を返す．

* make_graph(op_list, op1_limit, op2_limit, imem_layout,  omem_oayout)
	DFG を作る関数．クラスには属していない．
	パラメータの意味は以下の通り

	* op_list: アフィン変換の本体．
	  一つの要素が一つの出力を表す．
	  一つの出力に対して，入力番号と重みのペアのリストを持つ．

	* op1_limit: 1段目の演算器の入力数の制約

	* op2_limit: 2段目の演算器の入力数の制約

	* imem_layout: 入力メモリのレイアウト情報

	* omem_layout: 出力メモリのレイアウト情報

	まず，ここでは重みの種類が単純に 0.125 の整数倍なので
	実際には重みを掛けることはせずに重みの分だけ入力を重複させる．
	そのため，見かけ上は入力数が制限値よりも少なくなる場合がある．

	本当はこの入力を同じ演算器の入力にするかで生成されるハードウェアが変わってくるが，
	今の所何がよいやり方なのかわからないので現れた順にグループ化している．

### mem_layout.py

* MemLayout
  メモリのレイアウト情報を表すクラス．

  * __init__(self, memory_size, block_num, block_size, bank_size, method)
	初期化を行う．

	* memory_size: メモリサイズ．
	* block_num: ブロック数
	* block_size: ブロックサイズ
	* bank_size: バンクサイズ
	* method: レイアウト方法(今の所 1 or 2)

	memory_size <= block_num * block_size であること．
	メモリのデータは block_num 個のブロックに分割される．
	さらにブロック内のデータは bank_size 毎に分割される．
	一つのメモリブロックに対して一度に bank_size 個のデータが同時にアクセス可能である．

  * memory_size(self)
	メモリの総量を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * block_num(self)
	ブロック数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * block_size(self)
	ブロックサイズを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * ban_num(self)
	バンク数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * bank_size(self)
	バンクサイズを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * method(self)
	メソッド番号を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * block_id(self, i_id)
	i_id のデータが属するブロック番号を返す．

  * bank_id(self, i_id)
	i_id のデータが属するバンク番号を返す．

  * offset(self, i_id)
	i_id のデータのバンク内のオフセットを返す．

  * decode(self, addr)
	addr を block_id, bank_id, offset に分解する．

  * encode(self, block_id, bank_id, offset)
	block_id, bank_id, offset を addr に変換する．


### scheduling.py
スケジューリングを行う関数の実装

* mem_scheduling(node, step, mem_usage)
  メモリノードのスケジューリングを行う関数．
  * node: 対象の演算ノード
  * step: 現在の最終ステップ
  * mem_usage: メモリソースノードのスケジューリング結果を表す辞書

  下記の list_scheduling2() で用いられる関数．


* list_scheduling(dfg, node_list, op_limit)
  リストスケジューリングを行う関数．
  * dfg 対象のDFGノード
  * node_list スケジューリングを行う順番に並べたノードのリスト
  * op_list 演算器数の制約

  基本的に「リストスケジューリング」とは与えられたノードを順に取り出し，
  それを可能な限り最も早いコントロールステップに割り当てていくというものである．
  ただし，同一のコントロールステップで実行可能な演算器数に制約があるので，
  その制約を満たすことができない場合には後ろのコントロールステップにずらしてスケジュールされる．

  メモリソースノードの場合には演算器数の制約とは関係なく，
  同じコントロールステップで同じメモリブロックの異なるバンクに対するアクセスがある場合にはスケジュールできない．
  同じバンクであれば複数のアクセスが同一のコントロールステップにあることは構わない．

  この関数内ではコントロールステップ番号をキーにしてメモリアクセスの状況，演算器の使用数を保持する辞書を用意する．
  新たなノードがスケジュールされる度にこれらの辞書の内容が更新される．

* list_scheduling2(dfg, node_list, op_limit)
  リストスケジュールを行う別の関数
  * dfg 対象のDFGノード
  * node_list スケジューリングを行う順番に並べたノードのリスト
  * op_list 演算器数の制約

  list_scheduling() ではメモリソースノードも可能な限り最も早いコントロールステップにスケジュールされるため，
  読み出した値を使う演算ノードの実行タイミングと大きく離れる傾向がある．
  するとその途中結果を保持するためのレジスタが必要となる．
  そこで，メモリノードに関しては演算ノードから離れない位置にスケジュールするように変更したものがこの関数である．

  node_list からノードを取り出してスケジュールを行う際にはメモリソースノードを無視して演算ノードのみを対象とする．
  演算ノードをスケジュールする際に，その入力となっているメモリソースノードのスケジュールを上記の
  mem_scheduling() で行う．


* group_scheduling(op2node_list, base_step)
  詳細はわすれました．


* list_scheduing3(dfg, op_limit)
  もう一つのスケジューリング関数
  * dfg: 対象のDFG
  * op_limit: １段めの演算器数の制約


* eval_scheduling(dfg)
  スケジュールされたDFGの評価を行う．
  具体的には１段めの演算器数，２段めの演算器数，
  レジスタ数を計算する．


* scheduling(dfg, op_limit, s_method)
  スケジューリングを行う．
  * dfg: 対象のDFG
  * op_limit: 1段目の演算器数の制約
  * s_method: スケジューリング関数を選ぶ番号(1 or 2 or 3)

  単純に list_scheduling(), list_scheduling2(), list_shceduling3() を呼ぶだけ．


* print_schedule(dfg, fout)
  スケジューリング結果を出力する．


### binder.py
バインディングを行う関数の実装．

* reg_bind1(dfg, unit_mgr, var_list)
  レジスタのバインディングを行う関数．
  * dfg: 対象のDFG
  * unit_mgr: 演算器を管理するオブジェクト
  * var_list: 変数リスト

  変数リストに含まれる変数をレジスタに割り付ける．
  既存のレジスタに割り当てられない場合には
  unit_mgr に対してレジスタの生成を行う．

  内部では二部グラフの最大重みマッチングアルゴリズムを用いている．


* reg_bind2(dfg, unit_mgr, var_list)
  レジスタのバインディングを行う関数
  * dfg: 対象のDFG
  * unit_mgr: 演算器を管理するオブジェクト
  * var_list: 変数リスト

  変数リストに含まれる変数をレジスタに割り付ける．
  既存のレジスタに割り当てられない場合には
  unit_mgr に対してレジスタの生成を行う．

  こちらも二部グラフの最大重みマッチングアルゴリズムを用いているが，
  詳細は reg_bind1() と少し異なる．


* bind_register(dfg, unit_mgr)
  レジスタバインディングを行う．
  * dfg: 対象のDFG
  * unit_mgr: 演算器を管理するオブジェクト

  各変数の使用する時区間を調べ，
  互いに重なりを持つグループに分割し，
  各々グループごとに reg_bind2() を呼ぶ．


* input_binding(src_set_dict, max_fanin)
  セレクタの入力のバインディングを行う．
  * src_set_dict: cstep をキーにしてセレクタの入力のリストを納めた辞書
  * max_fanin セレクタの最大入力数

  複数の演算ノードを一つに演算器にバインドした場合，
  それぞれの演算ノードに応じて入力も切り替える必要がある．
  そのためにセレクタが必要となる．
  ただし，結果として異なる入力であってもそれが同じレジスタに割り当てられていた場合，
  それらを切り替えるセレクタは不要となる．
  一方，多入力加算は入力に対して対称性があるため，
  入力の順序を入れ替えても結果は変わらない．
  そこで，セレクタの総入力数が減るように入力の順番を考える．

  具体的には新しい入力を取り出す度に，
  割り当てられたレジスタを同じレジスタを持つ入力を探し，
  その位置に入力を割り当てる．
  なければ適当に割り当てる．


* alloc_op1_selecter(dfg, unit_mgr)
  1段目の演算器の入力セレクタの生成を行う．
  * dfg: 対象のDFG
  * unit_mgr: 演算器を管理するオブジェクト

* alloc_op2_selecter(dfg, unit_mgr)
  2段目の演算器の入力セレクタの生成を行う．
  * dfg: 対象のDFG
  * unit_mgr: 演算器を管理するオブジェクト

* bind(dfg)
  バインディングを行う．
  * dfg: 対象のDFG

  割り当て結果を保持する UnitMgr を返す．

  演算器に関しては単純に重複していないものを一つにまとめる．
  その後でレジスタ割り当てを行い，最後にセレクタの生成を行う．


### bipartite.py
二部グラフの最大マッチングを求める関数の実装．

* BiNode
  二部グラフのノードを表すクラス．

* BiEdge
  二部グラフの枝を表すクラス．

* make_path(edge, node)
  枝をたどって経路を求める．

* find_path(l_nodes, r_nodes, edge_list)
  二部グラフの最大重み経路を求める．
  * l_nodes: 左側のノードリスト
  * r_nodes: 右側のノードリスト
  * edge_list: 枝のリスト

* bipartite_matching(n_l, n_r, src_edge_list)
  二部グラフの最大重みマッチングを行う．
  * n_l: 左の節点数
  * n_r: 右の節点数
  * src_edge_list: 枝のリスト

  枝は(l, r, w)のタプルで表される．
  l, r は左と右の節点番号，wは重み．


### unit.py
演算器と演算器を管理するクラスの実装

* MuxSpec
  セレクタの仕様を表すクラス．

  * __init__(self)
	初期化を行う．

  * add_src(self, src, cstep)
	入力を追加する．
	* src: 入力のユニット
	* cstep: 実行ステップ

  * src_list(self)
	ソースのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * src_cond(self, src)
	ソースが用いられる条件(cstep)を返す．
	* src 対象の入力

  * src(self, cstep)
	* cstep 対象のコントロールステップ．
	cstep の時のソースを返す．
	対象のソースがない場合には None を返す．

* Unit
  演算器を表す基底クラス

  * __init__(self, id, input_num)
	初期化する．
	* id: ID番号
	* input_num: 入力数

  * id(self)
	ID番号を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * bind(self, node, cstep)
	ノードに割り当てる．
	* node: 対象のノード
	* cstep: コントロールステップ

  * _add_src(self, i, src, cstep)
	入力を設定する．
	* i: 入力番号
	* src: 入力
	* cstep: コントロールステップ

  * input_num(self)
	入力数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * mux_spec(self, i)
	i 番目の入力のセレクタの仕様を返す．

  * node(self, cstep)
    cstep に割り当てられたノードを返す．

  * is_load_unit(self)
	ロードユニットの時 True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * is_store_unit(seit)
	ストアユニットの時 True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * is_op1_unit(self)
    1段目の演算器ユニットの時 True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * is_op2_unit(self)
	2段目の演算器ユニットの時 True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * is_reg_unit(self)
	レジスタの時 True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

* MemoryBlock
  メモリブロックを表すクラス．
  Unit とは直接の関係はない．

  * __init__(self, block_id, bank_num, bank_size)
	初期化する．
	* block_id: ブロック番号
	* bank_num: バンク数
	* bank_size: バンクサイズ

  * block_id(self)
	ブロック番号を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * add_cond(self, cstep, bank_id)
	バンクの選択条件を追加する．
	* cstep: コントロールステップ
	* bank_id: バンク番号

  * bank_dict(self)
	cstep をキーとして選択するバンク番号を納めた辞書を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * cond_dict(self)
	バンク番号をキーにしてそれが選ばれているコントロールステップのリストを納めた辞書を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * set_val(self, bank_id, offset, val)
	値を設定する．
	* bank_id: バンク番号
	* offset: オフセット
	* val: 値

  * get_val(bank_id, offset)
	値を取得する．
	* bank_id: バンク番号
	* offset: オフセット


* LoadUnit
  ロードユニットを表すクラス．
  Unit を継承している．

  * __init__(self, id, mem_block, offset)
	初期化する．
	* id: ID番号
	* mem_block: メモリブロック
	* offset: オフセット

  * add_cond(self, cstep, bank_id)
	バンク選択条件を追加する．
	* cstep: コントロールステップ
	* bank_id: バンク番号

	cstep で bank_id が選択されるという条件を追加する．

  * is_load_unit(self)
	ロードユニットの時 True を返す．
	このクラスでは常に True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * block(self)
	メモリブロックを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * block_id(self)
    ブロック番号を返す．

  * offset(self)
	オフセットを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * bank_dict(self)
	cstep をキーとしてその時に選択されるバンク番号を納めた辞書を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * eval_on(self, step)
	cstep における評価を行う．

  * sync(sefl)
	直前の eval_on() の結果を同期させる．

  * value(self)
	評価結果を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

* StoreUnit
  ストアユニットを表すクラス．
  Unit を継承している．

  * __init__(self, id, mem_block)
	初期化する．
	* id: ID番号
	* mem_block: メモリブロック

  * add_src(self, src, cstep, bank_id)
	ストア条件を追加する．
	* src: 入力
	* cstep: コントロールステップ
	* bank_id: バンク番号

  * is_store_unit(self)
	ストアユニットの時 True を返す．
	このクラスでは常に True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * block(self)
	メモリブロックを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * block_id(self)
	ブロック番号を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * bank_dict(self)
	cstep をキーとしてその時に選択されるバンク番号を納めた辞書を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * eval_on(self, step)
	cstep における評価を行う．

  * sync(sefl)
	直前の eval_on() の結果を同期させる．

* ThroughUnit
  Through タイプユニットを表すクラス．
  Unit を継承している．

  * __init__(self, id, src)
	初期化する．
	* id: ID番号
	* src: 入力

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * src(self)
	入力を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * eval_on(self, step)
	cstep における評価を行う．

* Op1Unit
  1段目の演算器ユニット

  * __init__(self, id, op_id, input_num)
    初期化する．
	id: ID番号
	op_id: 演算器番号
	input_num: 入力数

  * add_src(self, i, src, cstep, inv)
	入力条件を追加する．
	* i: 入力番号
	* src: 入力
	* cstep: コントロールステップ
	* inv: 反転フラグ

	負の重みの場合には inv を True にする．

  * is_op1_unit(self)
	1段目の演算器ユニットの時 True を返す．
	このクラスでは常に True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op_id(self)
	演算器番号を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * inv_cond(self, i)
	i番目の入力の反転フラグの条件を表す辞書を返す．

  * eval_on(self, cstep)
	cstep における評価を行う．

* Op2Unit
  2段目の演算器ユニットを表すクラス
  Unit を継承している．

  * __init__(self, id, op_id, input_num)
	初期化する．
	* id: ID番号
	* op_id: 演算器番号
	* input_num: 入力数

  * add_src(self, i, src, cstep)
	入力条件を追加する．
	* i: 入力番号
	* src: 入力
	* cstep: コントロールステップ

  * add_bias(self, bias, cstep)
	バイアス条件を追加する．
	* bias: バイアス値
	* cstep: コントロールステップ

  * is_op2_unit(self)
	2段目の演算器ユニットの時 True を返す．
	このクラスでは常に True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op_id(self)
	演算器番号を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * bias_map(self)
	バイアス値の辞書(キーはcstep)を返す．

  * eval_on(self, cstep)
	cstep における評価を行う．

* RegUnit
  レジスタを表すクラス．
  Unit を継承している．

  * __init__(self, id, reg_id)
	初期化する．
	* id: ID番号
	* reg_id: レジスタ番号

  * add_src(self, node)
	ソースを追加する．
	* node: 入力のノード

  * is_reg_unit(self)
	レジスタユニットの時 True を返す．
	このクラスでは常に True を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * reg_id(self)
	レジスタ番号を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * name(self)
	このノードの名前を返す．主にデバッグ用
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * var_list(self)
	割り当てられている変数のリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * last_step(self)
	最後のステップを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * has_samesrc(self, node)
	node と同じソースを持っていたら True を返す．

  * src_map(self)
	ソースの辞書(キーはcstep)を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * cond_map(self)
	条件(cstep)の辞書(キーはユニット番号)を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * eval_on(self, cstep)
	cstep における評価を行う．

  * sync(sefl)
	直前の eval_on() の結果を同期させる．

  * value(self)
	評価結果を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

* UnitMgr
  ユニットを管理するクラス．

  * __init__(self, imem_layout, omem_layout, total_step)
	初期化する．
	* imem_layout: 入力メモリのレイアウト
	* omem_layout: 出力メモリのレイアウト
	* total_step: 総ステップ数

  * imem_layout(self)
	入力メモリのレイアウトを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * omem_layout(self)
	出力メモリのレイアウトを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * total_step(self)
	総ステップ数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * unit_list(self)
	全てのユニットのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * unit(self, unit_id)
	ユニット番号からユニットを返す．

  * load_memory_list(self)
	ロードメモリのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * load_memory(self, block_id)
	block_id からロードメモリを返す．

  * load_unit_list(self)
	ロードユニットのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * store_memory_list(self)
	ストアメモリのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * store_memory(self, block_id)
	block_id からストアメモリを返す．

  * store_unit_list(self)
	ストアユニットのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op1_num(self)
	1段目の演算器ユニット数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op1(self, pos)
	pos 番目の演算器ユニットを返す．

  * op1_list(self)
	1段目の演算器ユニットのリストを返す．

  * op2_num(self)
	2段目の演算器ユニット数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * op2(self, pos)
	pos 番目の演算器ユニットを返す．

  * op2_list(self)
	2段目の演算器ユニットのリストを返す．

  * reg_num(self)
	レジスタ数を返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * reg(self, pos)
	pos 番目のレジスタを返す．

  * reg_list(self)
	レジスタのリストを返す．
	この関数は @property で修飾されているので，
	関数としてではなくメンバとしてアクセスされる．

  * new_load_unit(self, block_id, offset)
	ロードユニットを生成する．
	* block_id: ブロック番号
	* offset: オフセット
	生成したロードユニットを返す．

  * new_load_memory(self, block_id)
	ロードメモリを生成する．
	* block_id: ブロック番号
	生成したロードメモリを返す．

  * new_store_unit(self, block_id)
	ストアユニットを生成する．
	* block_id: ブロック番号
	生成したストアユニットを返す．

  * new_store_memory(self, block_id)
	ストアメモリを生成する．
	* block_id: ブロック番号
	生成したストアメモリを返す．

  * new_through_unit(self, src)
	スルーユニットを生成する．
	* src: 入力
	生成したスルーユニットを返す．

  * new_op1_unit(self, input_num)
	1段目の演算器ユニットを生成する．
	* input_num: 入力数
	生成した演算器ユニットを返す．

  * new_op2_unit(self, input_num)
	2段目の演算器ユニットを生成する．
	* input_num: 入力数
	生成した演算器ユニットを返す．

  * new_reg_unit(self)
	レジスタを生成する．
	生成したレジスタを返す．

  * simulate(self, ivals, oaddr_list, debug)
	シミュレーションを行う．
	* ivals: 入力値を納めた辞書
	* oaddr_list: 出力のアドレスのリスト
	* debug: デバッグフラグ
	出力値を納めた辞書を返す．

  * print(self, fout)
	内容を出力する．
